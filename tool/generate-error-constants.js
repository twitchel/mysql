#!/usr/bin/env node
var fs     = require('fs');
var path   = require('path');
var script = path.basename(__filename);

var srcDir5 = process.argv[2];
var srcDir8 = process.argv[3];
if (!srcDir5 || !srcDir8) {
  var args = [];
  args[0] = process.argv[0].indexOf(' ') !== -1
    ? '"' + process.argv[0] + '"'
    : process.argv[0];
  args[1] = process.argv[1].indexOf(' ') !== -1
    ? '"' + process.argv[1] + '"'
    : process.argv[1];
  args[2] = path.join('path', 'to', 'mysql5', 'src');
  args[3] = path.join('path', 'to', 'mysql8', 'src');
  console.error('Usage: ' + args.join(' '));
  process.exit(1);
}

var codes      = [];
var targetFile = path.join(__dirname, '..', 'lib', 'protocol', 'constants', 'errors.js');
var previous   = fs.existsSync(targetFile) ? require(targetFile) : {};
var stream     = fs.createWriteStream(targetFile);
var version5   = extractMySqlVersion(srcDir5);
if (!version5.startsWith('5.')){
  console.error('Expected ' + srcDir5 + ' to contain MySQL 5.x.x sources, got ' + version5);
  process.exit(1);
}
var version8   = extractMySqlVersion(srcDir8);
if (!version8.startsWith('8.')){
  console.error('Expected ' + srcDir5 + ' to contain MySQL 8.x.x sources, got ' + version8);
  process.exit(1);
}

appendGlobalErrorCodes(srcDir5, codes);
appendGlobalErrorCodes(srcDir8, codes);
appendDatabseErrorCodes(srcDir5, codes);
appendDatabseErrorCodes(srcDir8, codes);
appendSqlErrorCodes(srcDir5, codes, path.join(srcDir5, 'sql', 'share', 'errmsg-utf8.txt'));
appendSqlErrorCodes(srcDir8, codes, path.join(srcDir8, 'share', 'messages_to_clients.txt'));
keepUnusedCodes(previous, codes);

stream.write('/**\n * MySQL error constants\n *\n * Extracted from versions ' + version5 + ' and ' + version8 + '\n *\n * !! Generated by ' + script + ', do not modify by hand !!\n */\n\n');

var alignment = codes.reduce(maxLength, 0);
for (var i = 0; i < codes.length; i++) {
  if (i in codes) {
    stream.write('exports.' + codes[i] + (new Array(alignment - codes[i].length + 1)).join(' ') + ' = ' + i + ';\n');
  }
}

stream.write('\n// Lookup-by-number table\n');

var alignment = String(codes.length).length;
for (var i = 0; i < codes.length; i++) {
  if (i in codes) {
    stream.write('exports[' + i + ']' + (new Array(alignment - String(i).length + 1)).join(' ') + ' = \'' + codes[i] + '\';\n');
  }
}

console.log('Wrote constants to ' + targetFile);

function addIfNotDefined(codes, num, code) {
  if (!codes[num]) {
    codes[num] = code;
  }
}

function appendGlobalErrorCodes(srcDir, codes) {
  var headerFile = path.join(srcDir, 'include', 'mysys_err.h');
  var code       = '';
  var contents   = fs.readFileSync(headerFile, 'ascii');
  var block      = false;
  var match      = null;
  var num        = 0;
  var regexp     = /#define +(EE_[A-Z0-9_]+)\s+([0-9]+)/mg;

  while ((match = regexp.exec(contents))) {
    code = match[1];
    num  = Number(match[2]);

    if (!block) {
      block = code === 'EE_ERROR_FIRST';
      continue;
    }

    if (code === 'EE_ERROR_LAST') {
      break;
    }

    addIfNotDefined(codes, num, code);
  }

  return codes;
}

function appendDatabseErrorCodes(srcDir, codes) {
  var headerFile = path.join(srcDir, 'include', 'my_base.h');
  var code       = '';
  var contents   = fs.readFileSync(headerFile, 'ascii');
  var block      = false;
  var match      = null;
  var num        = 0;
  var regexp     = /#define +(HA_[A-Z0-9_]+)\s+([0-9]+)/mg;

  while ((match = regexp.exec(contents))) {
    code = match[1];
    num  = Number(match[2]);

    if (!block) {
      block = code === 'HA_ERR_FIRST';
      continue;
    }

    if (code === 'HA_ERR_LAST') {
      break;
    }

    addIfNotDefined(codes, num, code);
  }

  return codes;
}

function appendSqlErrorCodes(srcDir, codes, errorFile) {
  var contents  = fs.readFileSync(errorFile, 'utf-8').replace(/^#.*$/gm, '');
  var sections  = contents.split(/^start-error-number (\d+)$/m);

  for (var i = 1; i < sections.length; i += 2) {
    var offset = Number(sections[i]);
    var names  = sections[i + 1].match(/^([A-Z0-9_]+)/mg).map(fixupCode);

    for (var j = 0; j < names.length; j++) {
      addIfNotDefined(codes, offset + j, names[j]);
    }
  }

  return codes;
}

function extractMySqlVersion(srcDir) {
  var versionFile = path.join(srcDir, 'VERSION');
  var contents    = fs.readFileSync(versionFile, 'utf-8');
  var dictionary  = Object.create(null);

  contents.split('\n').forEach(function (line) {
    var pair = line.split('=');
    var key  = pair[0];
    var val  = pair.slice(1).join('=').trimRight();
    dictionary[key] = val;
  });

  return dictionary.MYSQL_VERSION_MAJOR + '.' +
    dictionary.MYSQL_VERSION_MINOR + '.' +
    dictionary.MYSQL_VERSION_PATCH;
}

function fixupCode(code) {
  return code
    // remove obsolete markers
    .replace(/^OBSOLETE_/, '')
    .replace(/^ER_OBSOLETE_/, 'ER_')
    // remove unused markers
    .replace(/(?:_OLD)?_+UNUSED$/, '');
}

function keepUnusedCodes(previousCodes, currentCodes) {
  for (var i = 0; i < currentCodes.length; i++) {
    if (/^ER_UNUSED\d*$/.test(currentCodes[i]) && previousCodes[i]) {
      currentCodes[i] = previousCodes[i];
    }
  }
}

function maxLength(max, value) {
  return Math.max(max, value.length);
}
